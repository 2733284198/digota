// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: payment/paymentpb/payment.proto

/*
	Package paymentpb is a generated protocol buffer package.

	It is generated from these files:
		payment/paymentpb/payment.proto

	It has these top-level messages:
		Charge
		Refund
		Card
		ChargeRequest
		GetRequest
		RefundRequest
		ListRequest
		ChargeList
*/
package paymentpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Currency int32

const (
	Currency_CUR_RESERVED Currency = 0
	Currency_AFN          Currency = 1
	Currency_ALL          Currency = 2
	Currency_AMD          Currency = 3
	Currency_ANG          Currency = 4
	Currency_ARS          Currency = 5
	Currency_AUD          Currency = 6
	Currency_AWG          Currency = 7
	Currency_AZN          Currency = 8
	Currency_BAM          Currency = 9
	Currency_BBD          Currency = 10
	Currency_BGN          Currency = 11
	Currency_BHD          Currency = 12
	Currency_BMD          Currency = 13
	Currency_BND          Currency = 14
	Currency_BOB          Currency = 15
	Currency_BRL          Currency = 16
	Currency_BSD          Currency = 17
	Currency_BWP          Currency = 18
	Currency_BYN          Currency = 19
	Currency_BYR          Currency = 20
	Currency_BZD          Currency = 21
	Currency_CAD          Currency = 22
	Currency_CLP          Currency = 23
	Currency_CNY          Currency = 24
	Currency_COP          Currency = 25
	Currency_CRC          Currency = 26
	Currency_CUP          Currency = 27
	Currency_CZK          Currency = 28
	Currency_DKK          Currency = 29
	Currency_DOP          Currency = 30
	Currency_DZD          Currency = 31
	Currency_EEK          Currency = 32
	Currency_EGP          Currency = 33
	Currency_EUR          Currency = 34
	Currency_FJD          Currency = 35
	Currency_FKP          Currency = 36
	Currency_GBP          Currency = 37
	Currency_GGP          Currency = 38
	Currency_GHC          Currency = 39
	Currency_GIP          Currency = 40
	Currency_GTQ          Currency = 41
	Currency_GYD          Currency = 42
	Currency_HKD          Currency = 43
	Currency_HNL          Currency = 44
	Currency_HRK          Currency = 45
	Currency_HUF          Currency = 46
	Currency_IDR          Currency = 47
	Currency_ILS          Currency = 48
	Currency_IMP          Currency = 49
	Currency_INR          Currency = 50
	Currency_IQD          Currency = 51
	Currency_IRR          Currency = 52
	Currency_ISK          Currency = 53
	Currency_JEP          Currency = 54
	Currency_JMD          Currency = 55
	Currency_JOD          Currency = 56
	Currency_JPY          Currency = 57
	Currency_KES          Currency = 58
	Currency_KGS          Currency = 59
	Currency_KHR          Currency = 60
	Currency_KPW          Currency = 61
	Currency_KRW          Currency = 62
	Currency_KWD          Currency = 63
	Currency_KYD          Currency = 64
	Currency_KZT          Currency = 65
	Currency_LAK          Currency = 66
	Currency_LBP          Currency = 67
	Currency_LKR          Currency = 68
	Currency_LRD          Currency = 69
	Currency_LTL          Currency = 70
	Currency_LVL          Currency = 71
	Currency_LYD          Currency = 72
	Currency_MAD          Currency = 73
	Currency_MKD          Currency = 74
	Currency_MNT          Currency = 75
	Currency_MUR          Currency = 76
	Currency_MXN          Currency = 77
	Currency_MWK          Currency = 78
	Currency_MYR          Currency = 79
	Currency_MZN          Currency = 80
	Currency_NAD          Currency = 81
	Currency_NGN          Currency = 82
	Currency_NIO          Currency = 83
	Currency_NOK          Currency = 84
	Currency_NPR          Currency = 85
	Currency_NZD          Currency = 86
	Currency_OMR          Currency = 87
	Currency_PAB          Currency = 88
	Currency_PEN          Currency = 89
	Currency_PHP          Currency = 90
	Currency_PKR          Currency = 91
	Currency_PLN          Currency = 92
	Currency_PYG          Currency = 93
	Currency_QAR          Currency = 94
	Currency_RON          Currency = 95
	Currency_RSD          Currency = 96
	Currency_RUB          Currency = 97
	Currency_RUR          Currency = 98
	Currency_SAR          Currency = 99
	Currency_SBD          Currency = 100
	Currency_SCR          Currency = 101
	Currency_SEK          Currency = 102
	Currency_SGD          Currency = 103
	Currency_SHP          Currency = 104
	Currency_SOS          Currency = 105
	Currency_SRD          Currency = 106
	Currency_SVC          Currency = 107
	Currency_SYP          Currency = 108
	Currency_THB          Currency = 109
	Currency_TND          Currency = 110
	Currency_TRL          Currency = 111
	Currency_TRY          Currency = 112
	Currency_TTD          Currency = 113
	Currency_TWD          Currency = 114
	Currency_TZS          Currency = 115
	Currency_UAH          Currency = 116
	Currency_UGX          Currency = 117
	Currency_AED          Currency = 118
	Currency_UYU          Currency = 119
	Currency_UZS          Currency = 120
	Currency_VEF          Currency = 121
	Currency_VND          Currency = 122
	Currency_XCD          Currency = 123
	Currency_YER          Currency = 124
	Currency_ZAR          Currency = 125
	Currency_ZMW          Currency = 126
	Currency_ZWD          Currency = 127
	Currency_USD          Currency = 128
)

var Currency_name = map[int32]string{
	0:   "CUR_RESERVED",
	1:   "AFN",
	2:   "ALL",
	3:   "AMD",
	4:   "ANG",
	5:   "ARS",
	6:   "AUD",
	7:   "AWG",
	8:   "AZN",
	9:   "BAM",
	10:  "BBD",
	11:  "BGN",
	12:  "BHD",
	13:  "BMD",
	14:  "BND",
	15:  "BOB",
	16:  "BRL",
	17:  "BSD",
	18:  "BWP",
	19:  "BYN",
	20:  "BYR",
	21:  "BZD",
	22:  "CAD",
	23:  "CLP",
	24:  "CNY",
	25:  "COP",
	26:  "CRC",
	27:  "CUP",
	28:  "CZK",
	29:  "DKK",
	30:  "DOP",
	31:  "DZD",
	32:  "EEK",
	33:  "EGP",
	34:  "EUR",
	35:  "FJD",
	36:  "FKP",
	37:  "GBP",
	38:  "GGP",
	39:  "GHC",
	40:  "GIP",
	41:  "GTQ",
	42:  "GYD",
	43:  "HKD",
	44:  "HNL",
	45:  "HRK",
	46:  "HUF",
	47:  "IDR",
	48:  "ILS",
	49:  "IMP",
	50:  "INR",
	51:  "IQD",
	52:  "IRR",
	53:  "ISK",
	54:  "JEP",
	55:  "JMD",
	56:  "JOD",
	57:  "JPY",
	58:  "KES",
	59:  "KGS",
	60:  "KHR",
	61:  "KPW",
	62:  "KRW",
	63:  "KWD",
	64:  "KYD",
	65:  "KZT",
	66:  "LAK",
	67:  "LBP",
	68:  "LKR",
	69:  "LRD",
	70:  "LTL",
	71:  "LVL",
	72:  "LYD",
	73:  "MAD",
	74:  "MKD",
	75:  "MNT",
	76:  "MUR",
	77:  "MXN",
	78:  "MWK",
	79:  "MYR",
	80:  "MZN",
	81:  "NAD",
	82:  "NGN",
	83:  "NIO",
	84:  "NOK",
	85:  "NPR",
	86:  "NZD",
	87:  "OMR",
	88:  "PAB",
	89:  "PEN",
	90:  "PHP",
	91:  "PKR",
	92:  "PLN",
	93:  "PYG",
	94:  "QAR",
	95:  "RON",
	96:  "RSD",
	97:  "RUB",
	98:  "RUR",
	99:  "SAR",
	100: "SBD",
	101: "SCR",
	102: "SEK",
	103: "SGD",
	104: "SHP",
	105: "SOS",
	106: "SRD",
	107: "SVC",
	108: "SYP",
	109: "THB",
	110: "TND",
	111: "TRL",
	112: "TRY",
	113: "TTD",
	114: "TWD",
	115: "TZS",
	116: "UAH",
	117: "UGX",
	118: "AED",
	119: "UYU",
	120: "UZS",
	121: "VEF",
	122: "VND",
	123: "XCD",
	124: "YER",
	125: "ZAR",
	126: "ZMW",
	127: "ZWD",
	128: "USD",
}
var Currency_value = map[string]int32{
	"CUR_RESERVED": 0,
	"AFN":          1,
	"ALL":          2,
	"AMD":          3,
	"ANG":          4,
	"ARS":          5,
	"AUD":          6,
	"AWG":          7,
	"AZN":          8,
	"BAM":          9,
	"BBD":          10,
	"BGN":          11,
	"BHD":          12,
	"BMD":          13,
	"BND":          14,
	"BOB":          15,
	"BRL":          16,
	"BSD":          17,
	"BWP":          18,
	"BYN":          19,
	"BYR":          20,
	"BZD":          21,
	"CAD":          22,
	"CLP":          23,
	"CNY":          24,
	"COP":          25,
	"CRC":          26,
	"CUP":          27,
	"CZK":          28,
	"DKK":          29,
	"DOP":          30,
	"DZD":          31,
	"EEK":          32,
	"EGP":          33,
	"EUR":          34,
	"FJD":          35,
	"FKP":          36,
	"GBP":          37,
	"GGP":          38,
	"GHC":          39,
	"GIP":          40,
	"GTQ":          41,
	"GYD":          42,
	"HKD":          43,
	"HNL":          44,
	"HRK":          45,
	"HUF":          46,
	"IDR":          47,
	"ILS":          48,
	"IMP":          49,
	"INR":          50,
	"IQD":          51,
	"IRR":          52,
	"ISK":          53,
	"JEP":          54,
	"JMD":          55,
	"JOD":          56,
	"JPY":          57,
	"KES":          58,
	"KGS":          59,
	"KHR":          60,
	"KPW":          61,
	"KRW":          62,
	"KWD":          63,
	"KYD":          64,
	"KZT":          65,
	"LAK":          66,
	"LBP":          67,
	"LKR":          68,
	"LRD":          69,
	"LTL":          70,
	"LVL":          71,
	"LYD":          72,
	"MAD":          73,
	"MKD":          74,
	"MNT":          75,
	"MUR":          76,
	"MXN":          77,
	"MWK":          78,
	"MYR":          79,
	"MZN":          80,
	"NAD":          81,
	"NGN":          82,
	"NIO":          83,
	"NOK":          84,
	"NPR":          85,
	"NZD":          86,
	"OMR":          87,
	"PAB":          88,
	"PEN":          89,
	"PHP":          90,
	"PKR":          91,
	"PLN":          92,
	"PYG":          93,
	"QAR":          94,
	"RON":          95,
	"RSD":          96,
	"RUB":          97,
	"RUR":          98,
	"SAR":          99,
	"SBD":          100,
	"SCR":          101,
	"SEK":          102,
	"SGD":          103,
	"SHP":          104,
	"SOS":          105,
	"SRD":          106,
	"SVC":          107,
	"SYP":          108,
	"THB":          109,
	"TND":          110,
	"TRL":          111,
	"TRY":          112,
	"TTD":          113,
	"TWD":          114,
	"TZS":          115,
	"UAH":          116,
	"UGX":          117,
	"AED":          118,
	"UYU":          119,
	"UZS":          120,
	"VEF":          121,
	"VND":          122,
	"XCD":          123,
	"YER":          124,
	"ZAR":          125,
	"ZMW":          126,
	"ZWD":          127,
	"USD":          128,
}

func (x Currency) String() string {
	return proto.EnumName(Currency_name, int32(x))
}
func (Currency) EnumDescriptor() ([]byte, []int) { return fileDescriptorPayment, []int{0} }

type ChargeStatus int32

const (
	ChargeStatus_Paid     ChargeStatus = 0
	ChargeStatus_Refunded ChargeStatus = 1
)

var ChargeStatus_name = map[int32]string{
	0: "Paid",
	1: "Refunded",
}
var ChargeStatus_value = map[string]int32{
	"Paid":     0,
	"Refunded": 1,
}

func (x ChargeStatus) String() string {
	return proto.EnumName(ChargeStatus_name, int32(x))
}
func (ChargeStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptorPayment, []int{1} }

type CardType int32

const (
	CardType_CARD_Reserved   CardType = 0
	CardType_Mastercard      CardType = 1
	CardType_Visa            CardType = 2
	CardType_AmericanExpress CardType = 3
	CardType_JCB             CardType = 4
	CardType_Discover        CardType = 5
	CardType_DinersClub      CardType = 6
)

var CardType_name = map[int32]string{
	0: "CARD_Reserved",
	1: "Mastercard",
	2: "Visa",
	3: "AmericanExpress",
	4: "JCB",
	5: "Discover",
	6: "DinersClub",
}
var CardType_value = map[string]int32{
	"CARD_Reserved":   0,
	"Mastercard":      1,
	"Visa":            2,
	"AmericanExpress": 3,
	"JCB":             4,
	"Discover":        5,
	"DinersClub":      6,
}

func (x CardType) String() string {
	return proto.EnumName(CardType_name, int32(x))
}
func (CardType) EnumDescriptor() ([]byte, []int) { return fileDescriptorPayment, []int{2} }

type PaymentProviderId int32

const (
	PaymentProviderId_PROVIDER_Reserved PaymentProviderId = 0
	PaymentProviderId_Stripe            PaymentProviderId = 1
	PaymentProviderId_Paypal            PaymentProviderId = 2
	PaymentProviderId_Braintree         PaymentProviderId = 3
)

var PaymentProviderId_name = map[int32]string{
	0: "PROVIDER_Reserved",
	1: "Stripe",
	2: "Paypal",
	3: "Braintree",
}
var PaymentProviderId_value = map[string]int32{
	"PROVIDER_Reserved": 0,
	"Stripe":            1,
	"Paypal":            2,
	"Braintree":         3,
}

func (x PaymentProviderId) String() string {
	return proto.EnumName(PaymentProviderId_name, int32(x))
}
func (PaymentProviderId) EnumDescriptor() ([]byte, []int) { return fileDescriptorPayment, []int{3} }

type RefundReason int32

const (
	RefundReason_GeneralError        RefundReason = 0
	RefundReason_Fraud               RefundReason = 1
	RefundReason_Duplicate           RefundReason = 2
	RefundReason_RequestedByCustomer RefundReason = 3
)

var RefundReason_name = map[int32]string{
	0: "GeneralError",
	1: "Fraud",
	2: "Duplicate",
	3: "RequestedByCustomer",
}
var RefundReason_value = map[string]int32{
	"GeneralError":        0,
	"Fraud":               1,
	"Duplicate":           2,
	"RequestedByCustomer": 3,
}

func (x RefundReason) String() string {
	return proto.EnumName(RefundReason_name, int32(x))
}
func (RefundReason) EnumDescriptor() ([]byte, []int) { return fileDescriptorPayment, []int{4} }

type ListRequest_Sort int32

const (
	ListRequest_Natural     ListRequest_Sort = 0
	ListRequest_CreatedDesc ListRequest_Sort = 1
	ListRequest_CreatedAsc  ListRequest_Sort = 2
	ListRequest_UpdatedDesc ListRequest_Sort = 3
	ListRequest_UpdatedAsc  ListRequest_Sort = 4
)

var ListRequest_Sort_name = map[int32]string{
	0: "Natural",
	1: "CreatedDesc",
	2: "CreatedAsc",
	3: "UpdatedDesc",
	4: "UpdatedAsc",
}
var ListRequest_Sort_value = map[string]int32{
	"Natural":     0,
	"CreatedDesc": 1,
	"CreatedAsc":  2,
	"UpdatedDesc": 3,
	"UpdatedAsc":  4,
}

func (x ListRequest_Sort) String() string {
	return proto.EnumName(ListRequest_Sort_name, int32(x))
}
func (ListRequest_Sort) EnumDescriptor() ([]byte, []int) { return fileDescriptorPayment, []int{6, 0} }

type Charge struct {
	Id               string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"_id"`
	Statement        string            `protobuf:"bytes,2,opt,name=statement,proto3" json:"statement,omitempty"`
	ChargeAmount     uint64            `protobuf:"varint,3,opt,name=chargeAmount,proto3" json:"chargeAmount,omitempty"`
	RefundAmount     uint64            `protobuf:"varint,4,opt,name=refundAmount,proto3" json:"refundAmount,omitempty"`
	Refunds          []*Refund         `protobuf:"bytes,5,rep,name=refunds" json:"refunds,omitempty"`
	Currency         Currency          `protobuf:"varint,6,opt,name=currency,proto3,enum=paymentpb.Currency" json:"currency,omitempty"`
	Email            string            `protobuf:"bytes,7,opt,name=email,proto3" json:"email,omitempty"`
	Paid             bool              `protobuf:"varint,8,opt,name=paid,proto3" json:"paid,omitempty"`
	Refunded         bool              `protobuf:"varint,9,opt,name=refunded,proto3" json:"refunded,omitempty"`
	ProviderId       PaymentProviderId `protobuf:"varint,10,opt,name=providerId,proto3,enum=paymentpb.PaymentProviderId" json:"providerId,omitempty"`
	ProviderChargeId string            `protobuf:"bytes,11,opt,name=providerChargeId,proto3" json:"providerChargeId,omitempty"`
	Created          int64             `protobuf:"varint,998,opt,name=created,proto3" json:"created,omitempty"`
	Updated          int64             `protobuf:"varint,999,opt,name=updated,proto3" json:"updated,omitempty"`
}

func (m *Charge) Reset()                    { *m = Charge{} }
func (m *Charge) String() string            { return proto.CompactTextString(m) }
func (*Charge) ProtoMessage()               {}
func (*Charge) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{0} }

func (m *Charge) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Charge) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *Charge) GetChargeAmount() uint64 {
	if m != nil {
		return m.ChargeAmount
	}
	return 0
}

func (m *Charge) GetRefundAmount() uint64 {
	if m != nil {
		return m.RefundAmount
	}
	return 0
}

func (m *Charge) GetRefunds() []*Refund {
	if m != nil {
		return m.Refunds
	}
	return nil
}

func (m *Charge) GetCurrency() Currency {
	if m != nil {
		return m.Currency
	}
	return Currency_CUR_RESERVED
}

func (m *Charge) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *Charge) GetPaid() bool {
	if m != nil {
		return m.Paid
	}
	return false
}

func (m *Charge) GetRefunded() bool {
	if m != nil {
		return m.Refunded
	}
	return false
}

func (m *Charge) GetProviderId() PaymentProviderId {
	if m != nil {
		return m.ProviderId
	}
	return PaymentProviderId_PROVIDER_Reserved
}

func (m *Charge) GetProviderChargeId() string {
	if m != nil {
		return m.ProviderChargeId
	}
	return ""
}

func (m *Charge) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Charge) GetUpdated() int64 {
	if m != nil {
		return m.Updated
	}
	return 0
}

type Refund struct {
	RefundAmount     uint64       `protobuf:"varint,1,opt,name=refundAmount,proto3" json:"refundAmount,omitempty"`
	ProviderRefundId string       `protobuf:"bytes,2,opt,name=providerRefundId,proto3" json:"providerRefundId,omitempty"`
	Reason           RefundReason `protobuf:"varint,3,opt,name=reason,proto3,enum=paymentpb.RefundReason" json:"reason,omitempty"`
	Created          int64        `protobuf:"varint,4,opt,name=created,proto3" json:"created,omitempty"`
}

func (m *Refund) Reset()                    { *m = Refund{} }
func (m *Refund) String() string            { return proto.CompactTextString(m) }
func (*Refund) ProtoMessage()               {}
func (*Refund) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{1} }

func (m *Refund) GetRefundAmount() uint64 {
	if m != nil {
		return m.RefundAmount
	}
	return 0
}

func (m *Refund) GetProviderRefundId() string {
	if m != nil {
		return m.ProviderRefundId
	}
	return ""
}

func (m *Refund) GetReason() RefundReason {
	if m != nil {
		return m.Reason
	}
	return RefundReason_GeneralError
}

func (m *Refund) GetCreated() int64 {
	if m != nil {
		return m.Created
	}
	return 0
}

type Card struct {
	Number      string   `protobuf:"bytes,1,opt,name=Number,proto3" json:"Number,omitempty" validate:"required,len=16"`
	ExpireMonth string   `protobuf:"bytes,2,opt,name=ExpireMonth,proto3" json:"ExpireMonth,omitempty" validate:"required,len=2"`
	ExpireYear  string   `protobuf:"bytes,3,opt,name=ExpireYear,proto3" json:"ExpireYear,omitempty" validate:"required,len=4"`
	FirstName   string   `protobuf:"bytes,4,opt,name=FirstName,proto3" json:"FirstName,omitempty" validate:"omitempty,min=1"`
	LastName    string   `protobuf:"bytes,5,opt,name=LastName,proto3" json:"LastName,omitempty" validate:"omitempty,min=1"`
	CVC         string   `protobuf:"bytes,6,opt,name=CVC,proto3" json:"CVC,omitempty" validate:"omitempty,len=3"`
	Type        CardType `protobuf:"varint,8,opt,name=type,proto3,enum=paymentpb.CardType" json:"type,omitempty" validate:"required,gte=1,lte=6"`
}

func (m *Card) Reset()                    { *m = Card{} }
func (m *Card) String() string            { return proto.CompactTextString(m) }
func (*Card) ProtoMessage()               {}
func (*Card) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{2} }

func (m *Card) GetNumber() string {
	if m != nil {
		return m.Number
	}
	return ""
}

func (m *Card) GetExpireMonth() string {
	if m != nil {
		return m.ExpireMonth
	}
	return ""
}

func (m *Card) GetExpireYear() string {
	if m != nil {
		return m.ExpireYear
	}
	return ""
}

func (m *Card) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *Card) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *Card) GetCVC() string {
	if m != nil {
		return m.CVC
	}
	return ""
}

func (m *Card) GetType() CardType {
	if m != nil {
		return m.Type
	}
	return CardType_CARD_Reserved
}

type ChargeRequest struct {
	Currency          Currency          `protobuf:"varint,1,opt,name=currency,proto3,enum=paymentpb.Currency" json:"currency,omitempty" validate:"required,gte=1,lte=128"`
	Total             uint64            `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty" validate:"required,gte=0"`
	Card              *Card             `protobuf:"bytes,3,opt,name=Card" json:"Card,omitempty" validate:"required,dive"`
	Email             string            `protobuf:"bytes,4,opt,name=email,proto3" json:"email,omitempty" validate:"email"`
	Statement         string            `protobuf:"bytes,5,opt,name=statement,proto3" json:"statement,omitempty"`
	PaymentProviderId PaymentProviderId `protobuf:"varint,6,opt,name=paymentProviderId,proto3,enum=paymentpb.PaymentProviderId" json:"paymentProviderId,omitempty" validate:"required,gte=1,lte=3"`
	Metadata          map[string]string `protobuf:"bytes,7,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ChargeRequest) Reset()                    { *m = ChargeRequest{} }
func (m *ChargeRequest) String() string            { return proto.CompactTextString(m) }
func (*ChargeRequest) ProtoMessage()               {}
func (*ChargeRequest) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{3} }

func (m *ChargeRequest) GetCurrency() Currency {
	if m != nil {
		return m.Currency
	}
	return Currency_CUR_RESERVED
}

func (m *ChargeRequest) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

func (m *ChargeRequest) GetCard() *Card {
	if m != nil {
		return m.Card
	}
	return nil
}

func (m *ChargeRequest) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *ChargeRequest) GetStatement() string {
	if m != nil {
		return m.Statement
	}
	return ""
}

func (m *ChargeRequest) GetPaymentProviderId() PaymentProviderId {
	if m != nil {
		return m.PaymentProviderId
	}
	return PaymentProviderId_PROVIDER_Reserved
}

func (m *ChargeRequest) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type GetRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" validate:"uuid4,required"`
}

func (m *GetRequest) Reset()                    { *m = GetRequest{} }
func (m *GetRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRequest) ProtoMessage()               {}
func (*GetRequest) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{4} }

func (m *GetRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type RefundRequest struct {
	Id     string       `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" validate:"uuid4,required"`
	Amount uint64       `protobuf:"varint,2,opt,name=amount,proto3" json:"amount,omitempty"`
	Reason RefundReason `protobuf:"varint,3,opt,name=reason,proto3,enum=paymentpb.RefundReason" json:"reason,omitempty" validate:"omitempty,gte=0,lte=3"`
}

func (m *RefundRequest) Reset()                    { *m = RefundRequest{} }
func (m *RefundRequest) String() string            { return proto.CompactTextString(m) }
func (*RefundRequest) ProtoMessage()               {}
func (*RefundRequest) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{5} }

func (m *RefundRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *RefundRequest) GetAmount() uint64 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *RefundRequest) GetReason() RefundReason {
	if m != nil {
		return m.Reason
	}
	return RefundReason_GeneralError
}

type ListRequest struct {
	Page  int64            `protobuf:"varint,1,opt,name=page,proto3" json:"page,omitempty" validate:"omitempty,required,gte=0"`
	Limit int64            `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty" validate:"omitempty,required,gt=0"`
	Sort  ListRequest_Sort `protobuf:"varint,3,opt,name=sort,proto3,enum=paymentpb.ListRequest_Sort" json:"sort,omitempty" validate:"omitempty,required,gte=0,lte=4"`
}

func (m *ListRequest) Reset()                    { *m = ListRequest{} }
func (m *ListRequest) String() string            { return proto.CompactTextString(m) }
func (*ListRequest) ProtoMessage()               {}
func (*ListRequest) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{6} }

func (m *ListRequest) GetPage() int64 {
	if m != nil {
		return m.Page
	}
	return 0
}

func (m *ListRequest) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *ListRequest) GetSort() ListRequest_Sort {
	if m != nil {
		return m.Sort
	}
	return ListRequest_Natural
}

type ChargeList struct {
	Charges []*Charge `protobuf:"bytes,1,rep,name=charges" json:"charges,omitempty"`
	Total   int32     `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *ChargeList) Reset()                    { *m = ChargeList{} }
func (m *ChargeList) String() string            { return proto.CompactTextString(m) }
func (*ChargeList) ProtoMessage()               {}
func (*ChargeList) Descriptor() ([]byte, []int) { return fileDescriptorPayment, []int{7} }

func (m *ChargeList) GetCharges() []*Charge {
	if m != nil {
		return m.Charges
	}
	return nil
}

func (m *ChargeList) GetTotal() int32 {
	if m != nil {
		return m.Total
	}
	return 0
}

func init() {
	proto.RegisterType((*Charge)(nil), "paymentpb.charge")
	proto.RegisterType((*Refund)(nil), "paymentpb.refund")
	proto.RegisterType((*Card)(nil), "paymentpb.card")
	proto.RegisterType((*ChargeRequest)(nil), "paymentpb.chargeRequest")
	proto.RegisterType((*GetRequest)(nil), "paymentpb.getRequest")
	proto.RegisterType((*RefundRequest)(nil), "paymentpb.refundRequest")
	proto.RegisterType((*ListRequest)(nil), "paymentpb.listRequest")
	proto.RegisterType((*ChargeList)(nil), "paymentpb.chargeList")
	proto.RegisterEnum("paymentpb.Currency", Currency_name, Currency_value)
	proto.RegisterEnum("paymentpb.ChargeStatus", ChargeStatus_name, ChargeStatus_value)
	proto.RegisterEnum("paymentpb.CardType", CardType_name, CardType_value)
	proto.RegisterEnum("paymentpb.PaymentProviderId", PaymentProviderId_name, PaymentProviderId_value)
	proto.RegisterEnum("paymentpb.RefundReason", RefundReason_name, RefundReason_value)
	proto.RegisterEnum("paymentpb.ListRequest_Sort", ListRequest_Sort_name, ListRequest_Sort_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Payment service

type PaymentClient interface {
	Charge(ctx context.Context, in *ChargeRequest, opts ...grpc.CallOption) (*Charge, error)
	Refund(ctx context.Context, in *RefundRequest, opts ...grpc.CallOption) (*Charge, error)
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Charge, error)
	List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ChargeList, error)
}

type paymentClient struct {
	cc *grpc.ClientConn
}

func NewPaymentClient(cc *grpc.ClientConn) PaymentClient {
	return &paymentClient{cc}
}

func (c *paymentClient) Charge(ctx context.Context, in *ChargeRequest, opts ...grpc.CallOption) (*Charge, error) {
	out := new(Charge)
	err := grpc.Invoke(ctx, "/paymentpb.Payment/Charge", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentClient) Refund(ctx context.Context, in *RefundRequest, opts ...grpc.CallOption) (*Charge, error) {
	out := new(Charge)
	err := grpc.Invoke(ctx, "/paymentpb.Payment/Refund", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*Charge, error) {
	out := new(Charge)
	err := grpc.Invoke(ctx, "/paymentpb.Payment/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentClient) List(ctx context.Context, in *ListRequest, opts ...grpc.CallOption) (*ChargeList, error) {
	out := new(ChargeList)
	err := grpc.Invoke(ctx, "/paymentpb.Payment/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Payment service

type PaymentServer interface {
	Charge(context.Context, *ChargeRequest) (*Charge, error)
	Refund(context.Context, *RefundRequest) (*Charge, error)
	Get(context.Context, *GetRequest) (*Charge, error)
	List(context.Context, *ListRequest) (*ChargeList, error)
}

func RegisterPaymentServer(s *grpc.Server, srv PaymentServer) {
	s.RegisterService(&_Payment_serviceDesc, srv)
}

func _Payment_Charge_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChargeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).Charge(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paymentpb.Payment/Charge",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).Charge(ctx, req.(*ChargeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Payment_Refund_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefundRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).Refund(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paymentpb.Payment/Refund",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).Refund(ctx, req.(*RefundRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Payment_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paymentpb.Payment/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Payment_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/paymentpb.Payment/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).List(ctx, req.(*ListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Payment_serviceDesc = grpc.ServiceDesc{
	ServiceName: "paymentpb.Payment",
	HandlerType: (*PaymentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Charge",
			Handler:    _Payment_Charge_Handler,
		},
		{
			MethodName: "Refund",
			Handler:    _Payment_Refund_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Payment_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Payment_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "payment/paymentpb/payment.proto",
}

func (m *Charge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Charge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if m.ChargeAmount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.ChargeAmount))
	}
	if m.RefundAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.RefundAmount))
	}
	if len(m.Refunds) > 0 {
		for _, msg := range m.Refunds {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintPayment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Currency != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Currency))
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if m.Paid {
		dAtA[i] = 0x40
		i++
		if m.Paid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Refunded {
		dAtA[i] = 0x48
		i++
		if m.Refunded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ProviderId != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.ProviderId))
	}
	if len(m.ProviderChargeId) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.ProviderChargeId)))
		i += copy(dAtA[i:], m.ProviderChargeId)
	}
	if m.Created != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Created))
	}
	if m.Updated != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Updated))
	}
	return i, nil
}

func (m *Refund) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Refund) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RefundAmount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.RefundAmount))
	}
	if len(m.ProviderRefundId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.ProviderRefundId)))
		i += copy(dAtA[i:], m.ProviderRefundId)
	}
	if m.Reason != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Reason))
	}
	if m.Created != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Created))
	}
	return i, nil
}

func (m *Card) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Card) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Number) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Number)))
		i += copy(dAtA[i:], m.Number)
	}
	if len(m.ExpireMonth) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.ExpireMonth)))
		i += copy(dAtA[i:], m.ExpireMonth)
	}
	if len(m.ExpireYear) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.ExpireYear)))
		i += copy(dAtA[i:], m.ExpireYear)
	}
	if len(m.FirstName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.FirstName)))
		i += copy(dAtA[i:], m.FirstName)
	}
	if len(m.LastName) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.LastName)))
		i += copy(dAtA[i:], m.LastName)
	}
	if len(m.CVC) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.CVC)))
		i += copy(dAtA[i:], m.CVC)
	}
	if m.Type != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *ChargeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChargeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Currency != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Currency))
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Total))
	}
	if m.Card != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Card.Size()))
		n1, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Email) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Email)))
		i += copy(dAtA[i:], m.Email)
	}
	if len(m.Statement) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Statement)))
		i += copy(dAtA[i:], m.Statement)
	}
	if m.PaymentProviderId != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.PaymentProviderId))
	}
	if len(m.Metadata) > 0 {
		for k, _ := range m.Metadata {
			dAtA[i] = 0x3a
			i++
			v := m.Metadata[k]
			mapSize := 1 + len(k) + sovPayment(uint64(len(k))) + 1 + len(v) + sovPayment(uint64(len(v)))
			i = encodeVarintPayment(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPayment(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintPayment(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *GetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *RefundRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefundRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPayment(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Amount))
	}
	if m.Reason != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *ListRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Page != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Page))
	}
	if m.Limit != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Limit))
	}
	if m.Sort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Sort))
	}
	return i, nil
}

func (m *ChargeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChargeList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Charges) > 0 {
		for _, msg := range m.Charges {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPayment(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Total != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPayment(dAtA, i, uint64(m.Total))
	}
	return i, nil
}

func encodeFixed64Payment(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Payment(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintPayment(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Charge) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	if m.ChargeAmount != 0 {
		n += 1 + sovPayment(uint64(m.ChargeAmount))
	}
	if m.RefundAmount != 0 {
		n += 1 + sovPayment(uint64(m.RefundAmount))
	}
	if len(m.Refunds) > 0 {
		for _, e := range m.Refunds {
			l = e.Size()
			n += 1 + l + sovPayment(uint64(l))
		}
	}
	if m.Currency != 0 {
		n += 1 + sovPayment(uint64(m.Currency))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	if m.Paid {
		n += 2
	}
	if m.Refunded {
		n += 2
	}
	if m.ProviderId != 0 {
		n += 1 + sovPayment(uint64(m.ProviderId))
	}
	l = len(m.ProviderChargeId)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	if m.Created != 0 {
		n += 2 + sovPayment(uint64(m.Created))
	}
	if m.Updated != 0 {
		n += 2 + sovPayment(uint64(m.Updated))
	}
	return n
}

func (m *Refund) Size() (n int) {
	var l int
	_ = l
	if m.RefundAmount != 0 {
		n += 1 + sovPayment(uint64(m.RefundAmount))
	}
	l = len(m.ProviderRefundId)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovPayment(uint64(m.Reason))
	}
	if m.Created != 0 {
		n += 1 + sovPayment(uint64(m.Created))
	}
	return n
}

func (m *Card) Size() (n int) {
	var l int
	_ = l
	l = len(m.Number)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.ExpireMonth)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.ExpireYear)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.FirstName)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.LastName)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.CVC)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovPayment(uint64(m.Type))
	}
	return n
}

func (m *ChargeRequest) Size() (n int) {
	var l int
	_ = l
	if m.Currency != 0 {
		n += 1 + sovPayment(uint64(m.Currency))
	}
	if m.Total != 0 {
		n += 1 + sovPayment(uint64(m.Total))
	}
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.Email)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	l = len(m.Statement)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	if m.PaymentProviderId != 0 {
		n += 1 + sovPayment(uint64(m.PaymentProviderId))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPayment(uint64(len(k))) + 1 + len(v) + sovPayment(uint64(len(v)))
			n += mapEntrySize + 1 + sovPayment(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	return n
}

func (m *RefundRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPayment(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovPayment(uint64(m.Amount))
	}
	if m.Reason != 0 {
		n += 1 + sovPayment(uint64(m.Reason))
	}
	return n
}

func (m *ListRequest) Size() (n int) {
	var l int
	_ = l
	if m.Page != 0 {
		n += 1 + sovPayment(uint64(m.Page))
	}
	if m.Limit != 0 {
		n += 1 + sovPayment(uint64(m.Limit))
	}
	if m.Sort != 0 {
		n += 1 + sovPayment(uint64(m.Sort))
	}
	return n
}

func (m *ChargeList) Size() (n int) {
	var l int
	_ = l
	if len(m.Charges) > 0 {
		for _, e := range m.Charges {
			l = e.Size()
			n += 1 + l + sovPayment(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovPayment(uint64(m.Total))
	}
	return n
}

func sovPayment(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPayment(x uint64) (n int) {
	return sovPayment(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Charge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: charge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: charge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChargeAmount", wireType)
			}
			m.ChargeAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChargeAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundAmount", wireType)
			}
			m.RefundAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refunds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Refunds = append(m.Refunds, &Refund{})
			if err := m.Refunds[len(m.Refunds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			m.Currency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currency |= (Currency(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Paid = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refunded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Refunded = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			m.ProviderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProviderId |= (PaymentProviderId(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderChargeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderChargeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 998:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 999:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			m.Updated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Updated |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Refund) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: refund: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: refund: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundAmount", wireType)
			}
			m.RefundAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderRefundId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderRefundId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (RefundReason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			m.Created = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Created |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Card) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: card: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: card: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Number = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireMonth", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpireMonth = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpireYear", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpireYear = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FirstName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CVC", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CVC = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (CardType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChargeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: chargeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: chargeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			m.Currency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Currency |= (Currency(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &Card{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Email", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Email = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Statement", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Statement = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentProviderId", wireType)
			}
			m.PaymentProviderId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentProviderId |= (PaymentProviderId(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthPayment
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(dAtA[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			if iNdEx < postIndex {
				var valuekey uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPayment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					valuekey |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				var stringLenmapvalue uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPayment
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					stringLenmapvalue |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				intStringLenmapvalue := int(stringLenmapvalue)
				if intStringLenmapvalue < 0 {
					return ErrInvalidLengthPayment
				}
				postStringIndexmapvalue := iNdEx + intStringLenmapvalue
				if postStringIndexmapvalue > l {
					return io.ErrUnexpectedEOF
				}
				mapvalue := string(dAtA[iNdEx:postStringIndexmapvalue])
				iNdEx = postStringIndexmapvalue
				m.Metadata[mapkey] = mapvalue
			} else {
				var mapvalue string
				m.Metadata[mapkey] = mapvalue
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: getRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: getRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefundRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: refundRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: refundRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (RefundReason(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: listRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: listRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Page", wireType)
			}
			m.Page = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Page |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sort", wireType)
			}
			m.Sort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sort |= (ListRequest_Sort(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChargeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: chargeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: chargeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Charges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPayment
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Charges = append(m.Charges, &Charge{})
			if err := m.Charges[len(m.Charges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPayment(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPayment
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPayment(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPayment
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPayment
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPayment
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPayment
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPayment(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPayment = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPayment   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("payment/paymentpb/payment.proto", fileDescriptorPayment) }

var fileDescriptorPayment = []byte{
	// 1922 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0xd8, 0x4f, 0x73, 0xdb, 0xb8,
	0x15, 0x00, 0x70, 0x53, 0xff, 0x2c, 0xc1, 0xb1, 0xf3, 0x82, 0xfc, 0x53, 0xbc, 0x59, 0xcb, 0xcb,
	0xec, 0x66, 0xbd, 0xde, 0xc4, 0x8e, 0x9d, 0x34, 0x9b, 0x26, 0x71, 0xb7, 0xa2, 0x20, 0xcb, 0x8e,
	0x24, 0x8a, 0x81, 0x2c, 0x2b, 0x52, 0xdb, 0x4d, 0x69, 0x11, 0x71, 0xd8, 0x95, 0x44, 0x85, 0xa4,
	0xdc, 0xb8, 0xff, 0x3f, 0x46, 0x67, 0x3a, 0x3d, 0xf5, 0xdc, 0x7b, 0x6f, 0xbd, 0xf6, 0xd8, 0xe9,
	0x07, 0xd0, 0x74, 0xd2, 0x99, 0xee, 0x5d, 0x9f, 0xa0, 0x83, 0x47, 0xca, 0x96, 0x2d, 0x3b, 0x9b,
	0xe9, 0xc9, 0x3f, 0x10, 0xef, 0x81, 0x00, 0x01, 0x02, 0xa2, 0x49, 0xa6, 0x67, 0x1e, 0x76, 0x44,
	0xd7, 0x5f, 0x0d, 0xff, 0xf6, 0xf6, 0x46, 0x5a, 0xe9, 0xb9, 0x8e, 0xef, 0xd0, 0xd4, 0x51, 0xc5,
	0xfc, 0xdd, 0x7d, 0xdb, 0x7f, 0xdd, 0xdf, 0x5b, 0x69, 0x39, 0x9d, 0xd5, 0x7d, 0x67, 0xdf, 0x59,
	0xc5, 0x88, 0xbd, 0xfe, 0x2b, 0x2c, 0x61, 0x01, 0x15, 0x64, 0xaa, 0xff, 0x8a, 0x92, 0x44, 0xeb,
	0xb5, 0xe9, 0xee, 0x0b, 0xba, 0x40, 0x22, 0xb6, 0x95, 0x56, 0x16, 0x95, 0xa5, 0x94, 0x36, 0x37,
	0x1c, 0x64, 0xc8, 0x9e, 0xe7, 0x74, 0x1f, 0xab, 0x2f, 0x6d, 0x4b, 0xe5, 0x11, 0xdb, 0xa2, 0x37,
	0x49, 0xca, 0xf3, 0x4d, 0x5f, 0xc8, 0x1b, 0xa5, 0x23, 0x32, 0x8c, 0x1f, 0x5f, 0xa0, 0x2a, 0xb9,
	0x10, 0xb4, 0x93, 0xed, 0x38, 0xfd, 0xae, 0x9f, 0x8e, 0x2e, 0x2a, 0x4b, 0x31, 0x7e, 0xe2, 0x9a,
	0x8c, 0x71, 0xc5, 0xab, 0x7e, 0xd7, 0x0a, 0x63, 0x62, 0x41, 0xcc, 0xf8, 0x35, 0xfa, 0x25, 0x99,
	0x0e, 0xca, 0x5e, 0x3a, 0xbe, 0x18, 0x5d, 0x9a, 0x59, 0xbf, 0xb4, 0x72, 0x34, 0xb8, 0x95, 0xa0,
	0x86, 0x8f, 0x22, 0xe8, 0x2a, 0x49, 0xb6, 0xfa, 0xae, 0x2b, 0xba, 0xad, 0xc3, 0x74, 0x62, 0x51,
	0x59, 0x9a, 0x5b, 0xbf, 0x3c, 0x16, 0x3d, 0xaa, 0xe2, 0x47, 0x41, 0xf4, 0x0a, 0x89, 0x8b, 0x8e,
	0x69, 0xb7, 0xd3, 0xd3, 0xd8, 0xff, 0xa0, 0x40, 0x29, 0x89, 0xf5, 0x4c, 0xdb, 0x4a, 0x27, 0x17,
	0x95, 0xa5, 0x24, 0x47, 0xd3, 0x79, 0x92, 0x0c, 0xee, 0x22, 0xac, 0x74, 0x0a, 0xaf, 0x1f, 0x95,
	0xe9, 0x53, 0x42, 0x7a, 0xae, 0x73, 0x60, 0x5b, 0xc2, 0xdd, 0xb6, 0xd2, 0x04, 0x6f, 0x7c, 0x73,
	0xec, 0xc6, 0xa1, 0x8c, 0xa3, 0x18, 0x3e, 0x16, 0x4f, 0x97, 0x09, 0x8c, 0x4a, 0x39, 0x7c, 0x3a,
	0xdb, 0x56, 0x7a, 0x06, 0xbb, 0x33, 0x71, 0x9d, 0xde, 0x20, 0xd3, 0x2d, 0x57, 0x98, 0xbe, 0xb0,
	0xd2, 0xff, 0x95, 0x5d, 0x8e, 0xf2, 0x51, 0x59, 0x56, 0xf5, 0x7b, 0x16, 0x56, 0x7d, 0x17, 0x56,
	0x85, 0x65, 0xf5, 0x2f, 0x0a, 0x49, 0x04, 0x9d, 0x9d, 0x78, 0xe4, 0xca, 0x19, 0x8f, 0x7c, 0xac,
	0x43, 0x1c, 0xaf, 0x6f, 0x5b, 0xe1, 0xfc, 0x4e, 0x5c, 0xa7, 0xab, 0xb2, 0x65, 0xd3, 0x73, 0xba,
	0x38, 0xc1, 0x73, 0xeb, 0xd7, 0x27, 0x67, 0x07, 0xab, 0x79, 0x18, 0x46, 0xd3, 0xc7, 0x23, 0x88,
	0x9d, 0x18, 0x80, 0xfa, 0xb7, 0x28, 0x89, 0xb5, 0x4c, 0xd7, 0xa2, 0x0f, 0x49, 0x42, 0xef, 0x77,
	0xf6, 0x84, 0x1b, 0x2e, 0xbe, 0x85, 0xe1, 0x20, 0x33, 0x7f, 0x60, 0xb6, 0x6d, 0x39, 0x9a, 0xc7,
	0xaa, 0x2b, 0xde, 0xf4, 0x6d, 0x57, 0x58, 0x77, 0xda, 0xa2, 0xbb, 0xb1, 0xf6, 0x50, 0xe5, 0x61,
	0x34, 0xfd, 0x9a, 0xcc, 0xe4, 0xdf, 0xf6, 0x6c, 0x57, 0x94, 0x9d, 0xae, 0xff, 0x3a, 0xe8, 0xb2,
	0xf6, 0xf1, 0x70, 0x90, 0xb9, 0x71, 0x4e, 0xf2, 0xba, 0xca, 0xc7, 0x33, 0xe8, 0x06, 0x21, 0x41,
	0xb1, 0x21, 0x4c, 0x17, 0x07, 0xf4, 0xfe, 0xfc, 0x07, 0x2a, 0x1f, 0x4b, 0xa0, 0x4f, 0x49, 0x6a,
	0xd3, 0x76, 0x3d, 0x5f, 0x37, 0x3b, 0x02, 0x07, 0x37, 0xd1, 0x75, 0xa7, 0x63, 0xfb, 0xa2, 0xd3,
	0xf3, 0x0f, 0xef, 0x74, 0xec, 0xee, 0xc6, 0x9a, 0xca, 0x8f, 0x13, 0xe8, 0x63, 0x92, 0x2c, 0x99,
	0x61, 0x72, 0xfc, 0x83, 0x92, 0x8f, 0xe2, 0xe9, 0x3d, 0x12, 0xcd, 0xed, 0xe6, 0x70, 0xc9, 0xbf,
	0x27, 0x4d, 0x76, 0xf9, 0xbe, 0xca, 0x65, 0x28, 0x2d, 0x91, 0x98, 0x7f, 0xd8, 0x13, 0xb8, 0xc4,
	0x4f, 0xbd, 0x25, 0xa6, 0x6b, 0xed, 0x1c, 0xf6, 0x84, 0x76, 0x6b, 0x38, 0xc8, 0x64, 0xce, 0x18,
	0xf9, 0xbe, 0x2f, 0x36, 0xd6, 0xee, 0xb4, 0x7d, 0xb1, 0xf1, 0x50, 0xe5, 0xd8, 0x8a, 0xfa, 0xa7,
	0x18, 0x99, 0x0d, 0xde, 0x6c, 0x2e, 0xde, 0xf4, 0x85, 0xe7, 0xd3, 0xdd, 0xb1, 0x37, 0x51, 0x39,
	0xf7, 0x4d, 0xd4, 0x3e, 0x1b, 0x0e, 0x32, 0x9f, 0xbc, 0xf7, 0x1e, 0x6b, 0xeb, 0x8f, 0xd4, 0xb1,
	0x17, 0xf6, 0x3e, 0x89, 0xfb, 0x8e, 0x6f, 0xb6, 0x71, 0x76, 0x63, 0xe7, 0xce, 0x8e, 0xcc, 0xbf,
	0xa7, 0xf2, 0x20, 0x96, 0x66, 0x49, 0x2c, 0x67, 0xba, 0x16, 0xce, 0xe8, 0xcc, 0xfa, 0xc5, 0x53,
	0x83, 0xd5, 0x6e, 0x0e, 0x07, 0x99, 0xf4, 0x19, 0x8d, 0x58, 0xf6, 0x81, 0x50, 0x39, 0xa6, 0xd2,
	0xe5, 0xd1, 0x46, 0x11, 0xcc, 0xeb, 0x95, 0xe1, 0x20, 0x03, 0xc7, 0x29, 0x58, 0xa5, 0x8e, 0xb6,
	0x8f, 0x13, 0x1b, 0x63, 0xfc, 0xf4, 0xc6, 0xe8, 0x90, 0x4b, 0x13, 0xfb, 0x41, 0xb8, 0x59, 0xbd,
	0x77, 0xcf, 0xf8, 0x80, 0xf9, 0xb8, 0xaf, 0xf2, 0xc9, 0xb6, 0xa9, 0x46, 0x92, 0x1d, 0xe1, 0x9b,
	0x96, 0xe9, 0x9b, 0xe9, 0x69, 0xdc, 0x42, 0x6f, 0x8f, 0x3f, 0x81, 0xf1, 0x69, 0x5b, 0x29, 0x87,
	0x81, 0xf9, 0xae, 0xef, 0x1e, 0xf2, 0xa3, 0xbc, 0xf9, 0x27, 0x64, 0xf6, 0x44, 0x15, 0x05, 0x12,
	0xfd, 0x56, 0x04, 0x53, 0x9b, 0xe2, 0x92, 0x72, 0x2b, 0x3d, 0x30, 0xdb, 0x7d, 0x11, 0x6e, 0x15,
	0x41, 0xe1, 0x71, 0xe4, 0x91, 0xa2, 0x3e, 0x21, 0x64, 0x5f, 0xf8, 0xa3, 0x95, 0x71, 0x77, 0xec,
	0x58, 0x39, 0x35, 0x7d, 0xfd, 0xbe, 0x6d, 0x3d, 0xb8, 0x33, 0x1a, 0x18, 0x9e, 0x32, 0xea, 0x5f,
	0x15, 0x32, 0x3b, 0xda, 0x48, 0xfe, 0x9f, 0x06, 0xe8, 0x35, 0x92, 0x30, 0x83, 0xbd, 0x0e, 0x97,
	0x0c, 0x0f, 0x4b, 0xb4, 0xf6, 0x81, 0x3b, 0x97, 0xf6, 0xe9, 0x70, 0x90, 0x59, 0x3c, 0xeb, 0x7d,
	0xc2, 0x45, 0x36, 0x7a, 0xf0, 0x61, 0x63, 0xea, 0xdf, 0x23, 0x64, 0xa6, 0x6d, 0x7b, 0x47, 0xc3,
	0x7d, 0x22, 0xcf, 0x92, 0x7d, 0x81, 0xfd, 0x8d, 0x6a, 0x9f, 0x0f, 0x07, 0x99, 0x5b, 0x67, 0xb5,
	0x75, 0x7a, 0xe5, 0x62, 0x12, 0x7d, 0x4a, 0xe2, 0x6d, 0xbb, 0x63, 0x07, 0x5d, 0x8f, 0x6a, 0xb7,
	0x87, 0x83, 0x8c, 0xfa, 0x3d, 0xd9, 0xb8, 0xec, 0x31, 0x89, 0x7e, 0x43, 0x62, 0x9e, 0xe3, 0xfa,
	0xe1, 0xf8, 0x3e, 0x1a, 0x1b, 0xdf, 0x58, 0x07, 0x57, 0xaa, 0x8e, 0xeb, 0x6b, 0x77, 0x87, 0x83,
	0xcc, 0x17, 0xdf, 0xdf, 0x2f, 0x1c, 0xec, 0x03, 0x95, 0x63, 0xbb, 0x6a, 0x8d, 0xc4, 0x64, 0x32,
	0x9d, 0x21, 0xd3, 0xba, 0xe9, 0xf7, 0x5d, 0xb3, 0x0d, 0x53, 0xf4, 0x22, 0x99, 0xc9, 0x05, 0x1b,
	0x3a, 0x13, 0x5e, 0x0b, 0x14, 0x3a, 0x47, 0x48, 0x78, 0x21, 0xeb, 0xb5, 0x20, 0x22, 0x03, 0x6a,
	0xc1, 0xb9, 0x84, 0x01, 0x51, 0x19, 0x10, 0x5e, 0x90, 0x01, 0x31, 0xb5, 0x42, 0x48, 0xb0, 0x28,
	0x4b, 0xb6, 0x87, 0xe7, 0x7f, 0x50, 0xf2, 0xd2, 0xca, 0xc4, 0xf9, 0x1f, 0x2e, 0xde, 0x51, 0x84,
	0x5c, 0x83, 0xc7, 0xbb, 0x43, 0x3c, 0x7c, 0xfd, 0x97, 0xff, 0x9c, 0x3a, 0xde, 0x8c, 0x28, 0x90,
	0x0b, 0xb9, 0x1a, 0x7f, 0xc9, 0xf3, 0xd5, 0x3c, 0xdf, 0xcd, 0x33, 0x98, 0xa2, 0xd3, 0x24, 0x9a,
	0xdd, 0xd4, 0x41, 0x41, 0x94, 0x4a, 0x10, 0x41, 0x94, 0x19, 0x44, 0x11, 0x7a, 0x01, 0x62, 0x08,
	0x5e, 0x85, 0x38, 0xa2, 0xc6, 0x20, 0x81, 0xa8, 0x17, 0x60, 0x1a, 0xd1, 0xd4, 0x21, 0x29, 0xa1,
	0x65, 0xcb, 0x90, 0x42, 0x68, 0x0c, 0x08, 0xa2, 0xa0, 0xc3, 0x0c, 0x62, 0x8b, 0xc1, 0x05, 0x44,
	0x99, 0xc1, 0x2c, 0x42, 0x67, 0x30, 0x87, 0xa8, 0x68, 0x70, 0x11, 0xc1, 0x4b, 0x00, 0x88, 0x2a,
	0x83, 0x4b, 0x88, 0xba, 0x01, 0x14, 0xd1, 0xd0, 0xe1, 0x72, 0x00, 0x0e, 0x57, 0x10, 0x4d, 0x06,
	0x57, 0x25, 0x72, 0x59, 0x06, 0xd7, 0x10, 0x25, 0x03, 0xae, 0x23, 0xf4, 0x06, 0xa4, 0x11, 0x15,
	0x03, 0x6e, 0x20, 0x78, 0x0e, 0xe6, 0x11, 0x35, 0x03, 0x3e, 0x42, 0x34, 0x8b, 0x70, 0x53, 0x82,
	0x15, 0x8b, 0xf0, 0x31, 0xa2, 0x62, 0xc0, 0x02, 0xa2, 0xc9, 0x20, 0x23, 0x91, 0xcf, 0x17, 0x61,
	0x11, 0x51, 0x30, 0xe0, 0x13, 0x44, 0x8d, 0x83, 0x2a, 0xb1, 0xf9, 0x8c, 0xc1, 0x2d, 0x44, 0xd1,
	0x80, 0x4f, 0x25, 0x0a, 0x9a, 0x01, 0x9f, 0x21, 0x0a, 0x06, 0xdc, 0x46, 0x6c, 0xe5, 0xe0, 0x73,
	0xc4, 0xb6, 0x01, 0x4b, 0x88, 0x9d, 0xe7, 0xf0, 0x05, 0xa2, 0xc1, 0x60, 0x59, 0x62, 0xab, 0xc8,
	0xe0, 0x4b, 0x84, 0x5e, 0x82, 0x3b, 0x08, 0x5e, 0x84, 0xbb, 0x88, 0xda, 0x26, 0xac, 0x48, 0x6c,
	0x33, 0x0e, 0xab, 0x88, 0x52, 0x15, 0xee, 0x21, 0xca, 0x06, 0xac, 0x21, 0x74, 0x0e, 0xeb, 0x88,
	0xe7, 0x0c, 0xee, 0x23, 0x38, 0x87, 0x07, 0x88, 0x6a, 0x11, 0x7e, 0x20, 0xf1, 0x2c, 0x6f, 0xc0,
	0x43, 0x44, 0x99, 0xc1, 0x57, 0x88, 0x0a, 0x83, 0x47, 0x08, 0xa3, 0x01, 0x3f, 0x94, 0x28, 0xe6,
	0xab, 0xf0, 0x18, 0x51, 0xa8, 0xc2, 0x13, 0xc4, 0x16, 0x87, 0xa7, 0x08, 0xa3, 0x0e, 0x1b, 0x08,
	0x5e, 0x87, 0x1f, 0x21, 0xea, 0x0c, 0xbe, 0x46, 0x34, 0x18, 0xfc, 0x18, 0xd1, 0xdc, 0x81, 0xac,
	0x44, 0x29, 0x5b, 0x04, 0x0d, 0xa1, 0x19, 0x90, 0x43, 0x14, 0x39, 0x30, 0x04, 0x67, 0x90, 0x47,
	0xec, 0x94, 0x60, 0x13, 0xb1, 0x5b, 0x82, 0x02, 0xa2, 0xc1, 0x60, 0x4b, 0xa2, 0x9c, 0x65, 0xb0,
	0x8d, 0x28, 0x32, 0x78, 0x86, 0xd0, 0x77, 0xa0, 0x88, 0xa8, 0x71, 0x28, 0x21, 0x5e, 0xe8, 0x50,
	0x46, 0xd4, 0x8b, 0xa0, 0x23, 0x1a, 0x1c, 0x2a, 0x88, 0xa6, 0x0e, 0x86, 0x84, 0x9e, 0x65, 0xf0,
	0x1c, 0x51, 0xd0, 0x81, 0x23, 0xb6, 0x2b, 0x50, 0x45, 0x54, 0x8a, 0xb0, 0x83, 0x30, 0x38, 0xd4,
	0x10, 0x4d, 0x06, 0xbb, 0x12, 0x95, 0x32, 0x87, 0xba, 0x84, 0x91, 0xd5, 0xe0, 0x05, 0x22, 0xaf,
	0x43, 0x03, 0xb1, 0x65, 0x40, 0x13, 0x51, 0xe4, 0xf0, 0x13, 0x44, 0x49, 0x87, 0x9f, 0x22, 0x1a,
	0x05, 0xf8, 0x99, 0xc4, 0xf3, 0x2c, 0x87, 0x6f, 0x24, 0x78, 0x45, 0x87, 0x97, 0x88, 0x2a, 0x83,
	0x9f, 0x23, 0x6a, 0x1a, 0x98, 0x01, 0x38, 0xec, 0x49, 0x54, 0xb3, 0x1c, 0x5a, 0x08, 0x8d, 0x81,
	0x85, 0xc8, 0x71, 0x10, 0x88, 0x7c, 0x11, 0x5e, 0x21, 0x0a, 0x0c, 0xf6, 0x11, 0x5b, 0x06, 0xbc,
	0x46, 0x54, 0xaa, 0x60, 0x23, 0x38, 0x83, 0x5f, 0x20, 0x76, 0x73, 0xf0, 0x2d, 0xa2, 0x61, 0x40,
	0x5b, 0x62, 0x67, 0x4b, 0x83, 0x0e, 0x42, 0x67, 0xd0, 0x45, 0xf0, 0x12, 0x38, 0x01, 0x1a, 0xd0,
	0x43, 0xec, 0x30, 0x78, 0x83, 0xa8, 0x33, 0x70, 0x11, 0xcd, 0x2a, 0x78, 0x12, 0xb5, 0xec, 0x16,
	0xf8, 0x88, 0xc2, 0x0b, 0xe8, 0xe3, 0xdb, 0x9d, 0x67, 0x70, 0x80, 0x57, 0x1a, 0x35, 0xf8, 0x25,
	0xa2, 0x59, 0x85, 0xb7, 0x12, 0xbb, 0xf9, 0x4d, 0x38, 0x44, 0xe8, 0x0c, 0x7e, 0x25, 0xf1, 0x22,
	0xc7, 0xe0, 0xd7, 0x12, 0x8d, 0x3c, 0x87, 0xdf, 0x48, 0x34, 0xb3, 0x1c, 0x7e, 0x8b, 0x28, 0xd7,
	0xe1, 0x77, 0x88, 0x3a, 0x83, 0xdf, 0xd3, 0x24, 0x89, 0xd6, 0xaa, 0x0c, 0xfe, 0xa0, 0x2c, 0xdf,
	0x1e, 0x7d, 0x2a, 0x55, 0x7d, 0xd3, 0xef, 0x7b, 0x34, 0x49, 0x62, 0x86, 0x69, 0x5b, 0x30, 0x45,
	0x2f, 0x90, 0x24, 0x0f, 0x3f, 0x32, 0x40, 0x59, 0xf6, 0x48, 0x72, 0xf4, 0xe3, 0x8c, 0x5e, 0x22,
	0xb3, 0xb9, 0x2c, 0x67, 0x2f, 0xb9, 0xf0, 0x84, 0x7b, 0x20, 0x64, 0xf0, 0x1c, 0x21, 0x65, 0xd3,
	0xf3, 0x85, 0x2b, 0x83, 0x40, 0x91, 0xcd, 0xec, 0xda, 0x9e, 0x09, 0x11, 0x7a, 0x99, 0x5c, 0xcc,
	0x76, 0x84, 0x6b, 0xb7, 0xcc, 0x6e, 0xfe, 0x6d, 0xcf, 0x15, 0x9e, 0x17, 0xec, 0x6d, 0xcf, 0x72,
	0x1a, 0xc4, 0xe4, 0x4d, 0x98, 0xed, 0xb5, 0x9c, 0x03, 0xe1, 0x42, 0x5c, 0xb6, 0xc2, 0xec, 0xae,
	0x70, 0xbd, 0x5c, 0xbb, 0xbf, 0x07, 0x89, 0xe5, 0xe7, 0x67, 0xfc, 0x5c, 0xa1, 0x57, 0xc9, 0x25,
	0x83, 0x57, 0x76, 0xb7, 0x59, 0x9e, 0x8f, 0xf7, 0x80, 0x90, 0x44, 0xd5, 0x77, 0xed, 0x9e, 0x00,
	0x45, 0xda, 0x30, 0x0f, 0x7b, 0x66, 0x1b, 0x22, 0x74, 0x96, 0xa4, 0x34, 0xd7, 0xb4, 0xbb, 0xbe,
	0x2b, 0x04, 0x44, 0x97, 0xab, 0xa3, 0x6f, 0x90, 0xe0, 0x80, 0x95, 0x5b, 0x72, 0x41, 0x74, 0x85,
	0x6b, 0xb6, 0xf3, 0xae, 0xeb, 0xb8, 0x30, 0x45, 0x53, 0x24, 0xbe, 0xe9, 0x9a, 0x7d, 0x39, 0x8a,
	0x59, 0x92, 0x62, 0xfd, 0x5e, 0xdb, 0x6e, 0x99, 0xbe, 0x80, 0x08, 0xbd, 0x4e, 0x2e, 0x87, 0x07,
	0x97, 0xb0, 0xb4, 0xc3, 0x5c, 0xdf, 0xf3, 0x9d, 0x8e, 0x70, 0x21, 0xba, 0xfe, 0x9d, 0x42, 0xa6,
	0x8d, 0xa0, 0xa3, 0xf4, 0x2b, 0x92, 0x08, 0xbe, 0x98, 0x68, 0xfa, 0xbc, 0x5f, 0x3a, 0xf3, 0x93,
	0xc7, 0x88, 0x3a, 0x25, 0x13, 0x83, 0xe7, 0x7d, 0x22, 0xf1, 0xc4, 0xcf, 0x8f, 0xb3, 0x13, 0xd7,
	0x48, 0xb4, 0x20, 0x7c, 0x7a, 0x75, 0xac, 0xee, 0xf8, 0x27, 0xcf, 0x79, 0xf7, 0x8a, 0xe1, 0x01,
	0x77, 0xed, 0xec, 0x73, 0x79, 0xfe, 0xea, 0x44, 0x92, 0x0c, 0x57, 0xa7, 0xb4, 0xa7, 0xff, 0x78,
	0xb7, 0xa0, 0xfc, 0xf3, 0xdd, 0x82, 0xf2, 0xef, 0x77, 0x0b, 0xca, 0x1f, 0xff, 0xb3, 0x30, 0xd5,
	0x5c, 0x1e, 0xfb, 0xc6, 0xb7, 0xec, 0x7d, 0xc7, 0x37, 0x47, 0x7f, 0x26, 0xfe, 0x51, 0xb0, 0x97,
	0xc0, 0xef, 0xfc, 0xfb, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x84, 0x52, 0xc5, 0x04, 0x44, 0x10,
	0x00, 0x00,
}
